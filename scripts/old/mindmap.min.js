mindmap = (function() {
    var v = new Date(1, 1, 2E3, 12, 0, 0),
    B = !1,
    z = 500;

    function indent_depth(b) {
        for (var r = 0, n = 0; n < b.length; n++) {
            var e = b.charAt(n);
            if(" " == e) r++;
            else if("\0" == e) return r;
            else return 0;
        }
        return 0;
    }

    function trim_label(b) {
        var r = {
            label: "",
            linkLabel: false,
            fixed: false,
            x: undefined, y: undefined
        };

        b = b.trim();
        if(b.length > 0 && b.charAt(0) == '\0' && b.charAt(1) == '-') {
            b = b.substring(2).trim();
        } else {
            return null;
        }

        if (b.match(/^\[[0-9\- ]*\]/)) {
            var n = b.indexOf("]");
            var ftok = ""
            0 < n && (ftok = b.substr(1, n - 1), b = b.substring(n + 1).trim())
            ftok = ftok.split(/  */)
            if(ftok.length == 2) {
                r.fixed = true
                r.x = ftok[0] * 1.0
                r.y = ftok[1] * 1.0
            }
        }

        if ("(" == b.charAt(0)) {
            var n = b.indexOf(")");
            0 < n && (r.linkLabel = b.substr(1, n - 1), b = b.substring(n + 1).trim())
        }
        r.label = b;
        return r
    }

    function moveViewToCurrentSelection() {
        d.moveViewToCurrentSelection()
    }
    
    function render(a) {
        d.execute(editorPane.getProcessed(), a)
        l = +new Date
        e()
        return false
    }

    function updateCanvasSize() {
        d.settings({
            width: $("#viewer-container").innerWidth(),
            height: $("#viewer-container").innerHeight()
        })
        d.redraw()
    }
    function redraw() {
        d.redrawAll()
    }

    function r(a) {
        if (new Date - v < z) setTimeout(r, z);
        else {
            B = !1;
            a = a ? $(window).innerWidth() -
                20 : $(window).innerWidth() - $("#leftPane").width() - 20;
            var g = $("#containerTable").height();
            d.settings({
                width: a,
                height: g
            })
            d.redrawAll()
        }
    }

    function n() {
        $("#logo i").hasClass("icon-chevron-down") ? ($("#logo i").removeClass("icon-chevron-down").addClass("icon-chevron-up"), $("#leftPane").hide()) : ($("#logo i").removeClass("icon-chevron-up").addClass("icon-chevron-down"), $("#leftPane").show());
        r(!0)
    }

    function e() {
        var a = 1 == d.settings("coloringMode", false) ? d.getLevels() + 1 : d.getBranches() + 1,
            g = 1 == d.settings("coloringMode", false) ? "Level" :
            "Branch";
        $("#colorsdiv").empty();
        for (var c = d.settings("bgcolors", false), h = 0; h < a; h++) {
            c[h] || (c[h] = c[c.length - 1], d.settings({
                bgcolors: c
            }));
            var e = 0 == h ? "Root" : g + " " + h;
            $("#colorsdiv").append("<input class='bgcolors' id='color" + h + "' pickerNbr=" + h + " data-default-value=" + c[h] + " type=text value='" + c[h] + "'>").append("<span class=s50>" + e + "</span><br>")
        }
        $(".bgcolors").minicolors({
            textfield: !1,
            change: function(a, b) {
                var g = d.settings("bgcolors", false);
                g[parseInt(picker)] = a;
                d.settings({
                    bgcolors: g
                })
            },
            show: function() {
                picker = $(this).attr("pickerNbr")
            },
            position: "top left",
            hideSpeed: 0,
            showSpeed: 0
        })
        d.redrawAll()
    }

/*
    function m(a) {
        try {
            editorPane.set(a.text);
            var g = {
                font: a.font,
                fontColor: a.fontColor,
                fontSize: parseInt(a.fontSize),
                lineColor: a.lineColor,
                lineWidth: parseFloat(a.lineWidth),
                coloringMode: parseInt(a.coloringMode),
                lockAfterMoving: parseInt(a.lockAfterMoving),
                bgcolors: JSON.parse(a.bgcolors),
                transform: JSON.parse(a.transform)
            };
            $(".fontcolor").minicolors("value", g.fontColor);
            $(".linecolor").minicolors("value", g.lineColor);
            var c = 1 == g.lockAfterMoving ? !0 : !1;
            $("#lockAfterMoving").prop("checked", c);
            if (1 == g.coloringMode) {
                $("#mode1").addClass("active")
                $("#mode2").removeClass("active")
            } else {
                $("#mode1").removeClass("active")
                $("#mode2").addClass("active")
            }
            d.settings(g);
            d.redrawAll()
            render(!0);
            var h = JSON.parse(a.positions);
            d.importPositions(h, a.version);
            hasChanged = !1;
            t = a.text;
            $(".saveMsg").hide()
        } catch (e) {
            alert("Sorry, there was an error while opening the mind map:\n" +
                e), render()
        }
    }
*/
  
    $(document).ready(function() {
        //TODO:
        d = new I("stageHolder", {
            width: $("#viewer-container").innerWidth(),
            height: $("#viewer-container").innerHeight()
        });
        hasChanged = !1;
        var s = null,
            t = "",
            l = 0;
        
        function findSelectedNodes(t) {
            var firstNodePos = 0
            var lastNodePos = 0

            var v = $(t).val().split("\n")
            var nodes = []
            var doCapture = false
            var accumPos = 0
            var nc = 0
            for(var i=0; i<v.length; i++) {
                accumPos += v[i].length + 1
                if(!doCapture) {
                    if(t.selectionStart < accumPos) {
                        doCapture = true
                    }
                }
                if(doCapture) {
                    if(v[i].match(/^\s*-/)) {
                        nodes.push(window.d.getNode(nc))
                    }
                    if(t.selectionEnd < accumPos) {
                        return nodes
                    }
                }
                if(v[i].match(/^\s*-/)) {
                    nc++
                }
            }
            return nodes
        }

        editorPane.on("keydown", function(a) {
            if(!editorPane.isEditable()) {
                return;
            }
            var g = this.selectionStart,
                c = this.selectionEnd,
                h = $(this).val(),
                e = h.lastIndexOf("\n", g - 1)

            // console.log("Key input", a.which, a.keyCode)
            if (a.ctrlKey && 219 == a.which) {
                // float
                a.preventDefault();

                let [nb, ne] = editorPane.findSelectedNodes()
                let xx = [];
                for(var i=nb; i<= ne; i++) {
                    const n = window.d.getNode(i);
                    n.fixed = false;
                    xx.push({nodenum: i, fixed: n.fixed, xp: n.x, yp: n.y});
                }
                editorPane.updateTextForCoordinates(xx);
            }
            else if (a.ctrlKey && 221 == a.which) {
                // fix
                a.preventDefault();

                let [nb, ne] = editorPane.findSelectedNodes()
                let xx = [];
                for(var i=nb; i<= ne; i++) {
                    const n = window.d.getNode(i);
                    n.fixed = true;
                    xx.push({nodenum: i, fixed: n.fixed, xp: n.x, yp: n.y});
                }
                editorPane.updateTextForCoordinates(xx);
            }
        });
        $(window).on("keydown", function(a) {
            if (13 == a.which && a.ctrlKey) {
                a.preventDefault();
                d.repositionFloatingNodes();
                render();
            }
        });
        $("#stageHolder").on("wheel", function(e) {
            d.zoom(-e.originalEvent.deltaY);
        });
        $("#lockAfterMoving").change(function() {
            d.settings({
                lockAfterMoving: $(this).prop("checked")
            })
            d.redrawAll()
        });

        $("#coloringMode").change(function(a) {
            d.settings({
                coloringMode: $(this).val()
            });
            d.redrawAll()
        });

        $("a.fonts").on("touchstart click", function(a) {
            d.settings({
                font: $(this).text()
            })
            d.redrawAll()
        });
        $("a.fontSize").on("mouseover touchstart", function() {
            d.settings({
                fontSize: $(this).text()
            })
            d.redrawAll()
        });
        $(".lineWidth").on("mouseover touchstart", function() {
            d.settings({
                lineWidth: $(this).attr("val")
            })
            d.redrawAll()
        });
        $("input.fontcolor").minicolors({
            textfield: !1,
            animationSpeed: 0,
            change: function(a, b) {
                d.settings({
                    fontColor: a
                })
                d.redrawAll()
            },
            position: "top left",
            hideSpeed: 0,
            showSpeed: 0
        });
        $("input.linecolor").minicolors({
            textfield: !1,
            animationSpeed: 0,
            change: function(a, b) {
                d.settings({
                    lineColor: a
                })
                d.redrawAll()
            },
            position: "top left",
            hideSpeed: 0,
            showSpeed: 0
        });
//        $("#mapEmail").keydown(function(a) {
//            13 == a.which && w()
//        });
//        $("#signInFromModal").on("touchstart click", function(a) {
//            a.stopPropagation();
//            a.preventDefault();
//            $(".user, .guest").hide();
//            $(".loginUser").show();
//            return !1
//        });
//        $("#signInBtn").on("touchstart click", function(a) {
//            setCookie()
//        });
//        $("#signOutFromModal").on("touchstart click", function(a) {
//            a.stopPropagation();
//            a.preventDefault();
//            $.get("index.php/user/signout/0", function() {
//                userid = user = logged_in = !1;
//                p()
//            });
//            return !1
//        });
//        $("#signInFromModalForm").submit(function(a) {
//            $("#signInMsg").hide();
//            a.preventDefault();
//            a = $("#signInFromModalForm .user_username").val();
//            var g = $("#signInFromModalForm .user_password").val();
//            a && g ? $.ajax({
//                type: "POST",
//                url: "index.php/user/signin",
//                data: $("#signInFromModalForm").serialize(),
//                success: function(a) {
//                    "0" != a && 0 != a && a ? (a = JSON.parse(a), userid = a.userid, user = a.user,
//                        logged_in = 1, p()) : $("#signInMsg").text("Sorry, wrong email/password combination").show()
//                },
//                error: function() {
//                    $("#signInMsg").text("Sorry, there seems to be a technical problem.").show()
//                }
//            }) : $("#signInMsg").text("Please provide your email and password to sign in").show();
//            return !1
//        });
//        $("#saveAsGuestLink").on("touchstart click", function(a) {
//            a.stopPropagation();
//            a.preventDefault();
//            $(".loginUser, .user").hide();
//            $(".guest").show()
//        });
//        $("#saveBtn, .saveBtn").on("touchstart click", function(a) {
//            a.stopPropagation();
//            a.preventDefault();
//            p();
//            return !1
//        });
//        $("#saveMindMapBtn").on("touchstart click", function(a) {
//            a.stopPropagation();
//            a.preventDefault();
//            w();
//            return !1
//        });
        $("#mindmap-lock-all").on("touchstart click", function(a) {
            a.stopPropagation();
            // a.preventDefault();
            d.setNodeLocks(!0);
            return !1
        });
        $("#mindmap-unlock-all").on("touchstart click", function(a) {
            a.stopPropagation();
            // a.preventDefault();
            d.setNodeLocks(!1);
            return !1
        });
        // x = editorPane.get().indexOf("\n", editorPane.get().indexOf("\n") + 1);
        // this.setSelectionRange && editorPane.setPos(x, x);
    });

    var lastXPos = 0, lastYPos = 0;
    var I = function(q, r) {
        function n(a, g, c) {
            c = "undefined" == typeof c ? !1 : c;
            var h = l.getTransform().m;
            if (c) return {
                x: (a - h[4]) / h[0],
                y: (g - h[5]) / h[3]
            };
            c = $("#" + q).offset();
            return {
                x: (a - c.left - h[4]) / h[0],
                y: (g - c.top - h[5]) / h[3]
            }
        }
        var e = {
                bgcolors: "#3f3a3a #2365ba #16c75e #ff481c #ffa81c #365C8E #31975A #C2583F #C2903F #9d9d9d".split(" "),
                coloringMode: 2,
                fontSize: 26,
                fontMinSize: 11,
                font: "Helvetica, Verdana, sans-serif",
                fontColor: "#ffffff",
                lineColor: "#cccccc",
                lineWidth: 1.5,
                scale: 1,
                lockAfterMoving: !0,
                linkLength: 10,
                friction: 0.9,
                charge: 1400,
                width: 400,
                height: 400,
                gravity: -0.001
            },
            e = $.extend({}, e, r),
            p = [],
            w = 0,
            y = "",
            A = 0,
            D = 0,
            C, m = [],
            x = !1,
            f, d = {
                nodes: [],
                links: []
            },
            s = 0,
            t = 0,
            l = new Kinetic.Layer,
            shiftKey = false,
            v = new Kinetic.Stage({
                container: q,
                width: e.width,
                height: e.height
            });
        v.add(l);
        l.move($("#viewer-container").innerWidth() / 2, $("#viewer-container").innerHeight() / 2)
        var B = document.getElementById(q),
            z = $("#" + q);
        z.on("touchstart mousedown", function(a) {
            shiftKey = a.shiftKey;
            (m.length > 0) || (x = !0, $(window).on("touchmove mousemove", function(a) {
                a.stopPropagation();
                a.preventDefault();
                s && t || (s = a.pageX || a.originalEvent.touches[0].pageX || a.originalEvent.changedTouches[0].pageX, t = a.pageY || a.originalEvent.touches[0].pageY || a.originalEvent.changedTouches[0].pageY);
                var b = a.pageX || a.originalEvent.touches[0].pageX || a.originalEvent.changedTouches[0].pageX;
                a = a.pageY || a.originalEvent.touches[0].pageY || a.originalEvent.changedTouches[0].pageY;
                l.move(b - s, a - t);
                s = b;
                t = a;
                l.draw()
            }));
            a.stopPropagation();
            // a.preventDefault()
        });
        z.on("touchmove mousemove", function(a) {
            lastXPos = a.pageX || a.originalEvent.touches[0].pageX || a.originalEvent.changedTouches[0].pageX;
            lastYPos = a.pageY || a.originalEvent.touches[0].pageY || a.originalEvent.changedTouches[0].pageY;
            let offset = $("#viewer-container").offset();
            lastXPos -= offset.left;
            lastYPos -= offset.top;
            shiftKey = a.shiftKey
            if(a.buttons == 0) {
                x && ($(window).unbind("touchmove mousemove"), x = !1);
                let xx = [];
                m.forEach((n, pos) => {
                    if(!n.data.parent) { m.fixed = e.lockAfterMoving; }
                    if(n.fixed) {
                        xx.push({nodenum: d.nodes.indexOf(n), fixed: n.fixed, xp:n.x, yp:n.y});
                    }
                })
                editorPane.updateTextForCoordinates(xx);
                t = s = false
                m = []
            }
            if(m.length > 0) {
                a = n(a.pageX || a.originalEvent.targetTouches[0].pageX, a.pageY || a.originalEvent.targetTouches[0].pageY)
                
                m.forEach((n) => {
                    n.x += a.x - C.x
                    n.y += a.y - C.y
                    n.px = n.x
                    n.py = n.y
                });
                C.x = a.x
                C.y = a.y
                
                that.updateFixedNodeCoordinates();

                if(f && 0.02 > f.alpha()) {
                    f.alpha(0.025)
                    f.restart()
                } else {
                    that.redraw();
                }
            }
        });
        $(window).on("mouseup touchend", function(a) {
            shiftKey = a.shiftKey;
            x && ($(window).unbind("touchmove mousemove"), x = !1);
            let xx = [];
            m.forEach((n, pos) => {
                if(!n.data.parent) { m.fixed = e.lockAfterMoving; }
                if(n.fixed) {
                    xx.push({nodenum: d.nodes.indexOf(n), fixed: n.fixed, xp:n.x, yp:n.y});
                }
            })
            editorPane.updateTextForCoordinates(xx);
            if(m.length > 0) {
                a.stopPropagation();
                // a.preventDefault()
            }
            t = s = false
            m = []
        });
        $(window).on("keyup", function(a) {
            shiftKey = a.shiftKey
        });
        $(window).on("keydown", function(a) {
            shiftKey = a.shiftKey
        });
        return that = {
            maxTextWidthCache: {},
            prevNb: -1, prevNe: -1,
            settings: function(a, g, c) {
                g = "undefined" == typeof g ? !0 : g;
                if ("object" == typeof a) {
                    e = $.extend({}, e, a);
                    if ("undefined" != typeof a.scale) {
                        c = l.getScale().x;
                        var d = a.scale;
                        l.setScale(d);
                        l.move( (l.getX() - lastXPos) * (d-c)/c, (l.getY() - lastYPos) * (d - c)/c);
                    }
                    if ("undefined" != typeof a.height || "undefined" != typeof a.width) {
                        f && f.stop(), v.setHeight(e.height), v.setWidth(e.width), f && f.alpha(0.02);
                    }
                    if ("undefined" != typeof a.transform) {
                        (h = a.transform, l.move(h[4], h[5]), l.setScale(h[0], h[3]));
                    }
                } else if ("string" == typeof a) return "transform" == a ? l.getTransform().m : e[a];
            },
            stopForce: function() {
                f && f.stop()
            },
            updateFixedNodeCoordinates : function() {
                d.nodes.forEach((x) => {
                    if(x.fixed) {
                        x.fx = x.x; x.fy = x.y;
                    } else {
                        x.fx = null; x.fy = null;
                    }
                });
            },
            createSimulation: function(size_scale) {
                // this calculates the 'w' and 'h', technically not for drawing
                that.redraw()

                // recalculate all 'parent size' parameter
                for(let i = 0; i < d.nodes.length; i++) {
                    let x = d.nodes[i];
                    x.area = x.w * x.h * size_scale * size_scale;
                    x.children_set = new Set();
                    x.children_set.add(x);
                }
                for(let i = d.nodes.length-1; i >= 0; i--) {
                    let x = d.nodes[i];
                    if(x.data.parent) {
                        for(let v of x.children_set) { x.data.parent.children_set.add(v); }
                        x.data.parent.area += x.area;
                    }
                }
                if(d.nodes.length > 0) {
                    d.nodes[0].fixed = true
                }

                d.nodes.forEach((x) => {
                    x.distance_map = new Map()
                    x.distance_map.set(x.id, 0);
                })

                for(let i=0; i<5; i++) {
                    d.links.forEach( (lnk) => {
                        let src = lnk.source;
                        let tgt = lnk.target;
                        for(let [n, d] of src.distance_map ) {
                            if(d == i && !tgt.distance_map.has(n)) {
                                tgt.distance_map.set(n, d+1);
                            }
                        }
                        for(let [n, d] of tgt.distance_map) {
                            if(d == i && !src.distance_map.has(n)) {
                                src.distance_map.set(n, d+1);
                            }
                        }
                    });
                }

                that.updateFixedNodeCoordinates()
                f = d3.forceSimulation(d.nodes)
                    .alpha(0.3)
                    .force("collide", d3.forceCollide((n) => {
                        return {x: n.w/2.2 * size_scale, y:n.h/2.2 * size_scale};
                    }).iterations(2).strength(0.3))
                    .force("link", d3.forceLink(d.links).strength(0.1).distance((link) => {
                        //return Math.max(20, 10+Math.sqrt(link.target.area)/2 - Math.max(link.target.w, link.target.h)/2, 10+Math.sqrt(link.source.area)/2 - Math.max(link.source.w, link.source.h)/2);
                        return 10;
                    }))
                    // .force("center", d3.forceCenter(0, 0).strength(-0.05))
                    .force("manybody", d3.forceManyBody().strength(-10).distanceMax(300))
                    // .force("x", d3.forceX())
                    // .force("y", d3.forceY())

                return f;
            },
            runSimulation: function() {
                //if(f) {
                //    f.restart()
                //} else {
                f = that.createSimulation(1.0);
                f.on("tick", function() {
                    var a = f.alpha();
                    0.011 > a && f.alpha(0.8 * a);
                    if(a < 0.02) {
                        d.nodes.forEach((x) => {
                            if(!x.data.parent) { x.fixed = true; x.fx = x.x; x.fy = x.y; }
                        });
                    }
                    that.redraw()
                }).on("end", function() {
                });
                //}
//                f.alpha(Math.min(0.1, Math.max(0.025, updatedRate)));
            },
            execute: function(a, g) {
                f && f.stop();
                that.text2mindmap(a)
                !0 !== g && (hasChanged = !0, $(".saveMsg").show());

                that.runSimulation()
            },
            getImage: function(a, b) {
                f.stop();
                var c = that.getBoundingBox(20),
                    h = 1 == b ? 1 : 2736 / c.width > 1889 / c.height ? 1889 / c.height : 2736 / c.width,
                    d = l.clone(),
                    e = l.getScale().x,
                    u = n(0, 0, !0);
                d.move(u.x * e, u.y * e);
                d.move(-c.left, -c.top);
                d.setScale(1);
                var k = new Kinetic.Stage({
                    container: "hiddenStage",
                    width: c.width * h,
                    height: c.height * h
                });
                k.add(d);
                k.setScale(h);
                d.draw();
                that.fillLayerBackground(d, "#FFFFFF");
                k.toDataURL({
                    mimeType: "image/jpeg",
                    quality: 1,
                    callback: function(b) {
                        a(b);
                        d.remove();
                        k.remove()
                    }
                })
            },
            fillLayerBackground: function(a, b) {
                var c = a.getCanvas(),
                    h = a.getContext();
                h.save();
                h.globalCompositeOperation = "destination-over";
                h.setTransform(1, 0, 0, 1, 0, 0);
                h.fillStyle = "#FFFFFF";
                h.fillRect(0, 0, c.width, c.height);
                h.restore()
            },
            clear: function() {
                l.removeChildren();
                d.nodes = d = {
                    nodes: [],
                    links: []
                };
                f = !1;
                y = "";
                that.execute("")
            },
            getBranches: function() {
                return A
            },
            getLevels: function() {
                return D
            },
            zoom: function(a) {
                let aorg = l.getScale().x;
                if(a > 0) {
                    a = Math.max(0.5, aorg * 1.1);
                } else {
                    a = Math.max(0.5, aorg / 1.1);
                }
                that.settings({
                    scale: a
                })
                that.redraw()
/*
                if (0 < a && 1 > l.getScale().x) {
                    a = Math.min(1, 1.1 * l.getScale().x)
                    that.settings({
                        scale: a
                    })
                    that.redrawAll()
                } else {
                    var b = 23 / Math.pow(0.8, 3);
                    if (!(0 > a && e.fontSize <= e.fontMinSize || 0 < a && e.fontSize >= b || !1 == f)) {
                        f.stop();
                        var c = 0 < a ? 1 : -1;
                        d.nodes.forEach(function(a) {
                            a.x += 0.2 * (a.x - 0.5 * v.getWidth()) * c;
                            a.y += 0.2 * (a.y - 0.5 * v.getHeight()) * c;
                            a.px = a.x;
                            a.py = a.y
                        });
                        a = 0 > a ? {
                            fontSize: Math.max(e.fontMinSize, 0.8 * e.fontSize),
                            linkLength: Math.max(20, 0.7 * e.linkLength),
                            charge: Math.max(230, 0.6 * e.charge),
                            friction: Math.max(0.87, e.friction - 0.01),
                            gravity: Math.max(0.025, e.gravity - 0.015)
                        } : {
                            fontSize: Math.min(23 / Math.pow(0.8, 3), e.fontSize / 0.8),
                            linkLength: Math.min(80 / Math.pow(0.7, 3), e.linkLength / 0.7),
                            charge: Math.min(1700 / Math.pow(0.6, 3), e.charge / 0.6),
                            friction: Math.min(0.9, e.friction + 0.01),
                            gravity: Math.min(0.1, e.gravity + 0.015)
                        };
                        that.settings(a);
                        that.redrawAll()
                        f.start()
                    }
                }
*/
            },
            getBoundingBox: function(a) {
                a || (a = 0);
                for (var b = 9999, c = 9999, d = -9999, e = -9999, f = l.getChildren(), u = 0; u < f.length; u++) {
                    var k = f[u];
                    if ("Group" == k.nodeType) {
                        var E = 0.5 * k.children[0].attrs.width,
                            F = 0.5 * k.children[0].attrs.height;
                        k.attrs.x - E < c && (c = k.attrs.x - E);
                        k.attrs.y - F < b && (b = k.attrs.y - F);
                        k.attrs.x + E > d && (d = k.attrs.x + E);
                        k.attrs.y + F > e && (e = k.attrs.y + F)
                    }
                }
                return {
                    left: c - a,
                    right: d + a,
                    top: b - a,
                    bottom: e + a,
                    width: d - c + 2 * a,
                    height: e - b + 2 * a
                }
            },
            addNode: function(a, b) {
                f && f.stop();
                var c = {
                    id: w++,
                    fixed: b.fixed,
                    x: b.x,
                    y: b.y,
                    px: b.x,
                    py: b.y,
                    data: b
                };
                d.nodes.splice(a, 0, c);
                return c
            },
            addLink: function(a, b) {
                d.links.push({
                    source: a,
                    target: b,
                    data: {
                        color: e.lineColor,
                        weight: e.lineWidth,
                        label: a.data.linkLabel
                    }
                })
            },
            getNode: function(x) {
                return d.nodes[x]
            },
            findNode: function(a) {
                for (var b = 0; b < d.nodes.length; b++)
                    if (parseInt(d.nodes[b].id) ==
                        parseInt(a)) return d.nodes[b];
                return !1
            },
            getLinksFrom: function(a) {
                var b = [];
                d.links.forEach(function(c) {
                    c.source.id == a.id && b.push(c)
                });
                return b
            },
            getLinksTo: function(a) {
                var b = [];
                d.links.forEach(function(c) {
                    c.target.id == a.id && b.push(c)
                });
                return b
            },
            isLinkedTo: function(a, b) {
                for (var c = 0; c < d.links.length; c++)
                    if (d.links[c].source.id == a.id && d.links[c].target.id == b.id) return !0;
                return !1
            },
            removeLink: function(a) {
                d.links.forEach(function(b, c) {
                    b == a && (b.ui && (b.ui.hasOwnProperty("removeChildren") && b.ui.removeChildren(), b.ui.remove()), d.links.splice(c, 1))
                })
            },
            setNodeLocks: function(a) {
                let xx = [];
                d.nodes.forEach(function(b, pos) {
                    b.data.parent &&
                        (b.fixed = a, xx.push({nodenum: pos, fixed: b.fixed, xp: b.x, yp: b.y}))
                });
                editorPane.updateTextForCoordinates(xx); 

                that.execute(editorPane.getProcessed(), false)

                // f && !1 == a && f.resume()
            },
            removeNode: function(a) {
                f && f.stop();
                var b = d.nodes[a];
                b ? (that.getLinksFrom(b).forEach(function(a) {
                    that.removeLink(a)
                }), that.getLinksTo(b).forEach(function(a) {
                    that.removeLink(a)
                }), "undefined" != typeof b && (b.ui.removeChildren(), b.ui.remove()), d.nodes.splice(a, 1)) : console.log("Could node find node with pos:" + a + "\n\n" + JSON.stringify(d.nodes))
            },
            setStartPosition: function(a, id, total_cnt) {
                if (!1 == a.data.parent) {
                    if(id == 0) {
                        return a.x = 0, a.y = 0, a.px = a.x, a.py = a.y, a;
                    }
                    let r = Math.sqrt(total_cnt) * 100;
                    let r1val = Math.cos(id / total_cnt * 3.141592 * 2);
                    let r2val = Math.sin(id / total_cnt * 3.141592 * 2);
                    return a.x = r * r1val, a.y = r * r2val, a.px = a.x, a.py = a.y, a;
                }
                a.x = a.data.parent.x;
                a.y = a.data.parent.y;

                if(false == a.data.parent.data.parent) {
                    var vx = 0
                    var vy = 0
                } else {
                    var vx = a.x - a.data.parent.data.parent.x
                    var vy = a.y - a.data.parent.data.parent.y
                }

                var b = a.data.parent.data.children;
                b || (b = 4);

                p[a.data.parent.id] || (p[a.data.parent.id] = 1);
                var c = p[a.data.parent.id]++,
                    b = 2 * Math.PI / b * c - Math.PI,
                    c = 20

                var l = Math.sqrt(vx*vx+vy*vy)
                if(l < 1e-3) {
                    var cosine = Math.cos(b)
                    var sine = Math.sin(b)
                    vx = 1
                    vy = 0
                    a.x += c * (cosine * vx + sine * vy) + Math.random() * 5
                    a.y += c * (-sine * vx + cosine * vy) + Math.random() * 5
                } else {
                    var cosine = Math.cos(b/4)
                    var sine = Math.sin(b/4)
                    vx /= l
                    vy /= l
                    a.x += c * (cosine * vx + sine * vy) + Math.random() * 5
                    a.y += c * (-sine * vx + cosine * vy) + Math.random() * 5
                }
                a.px = a.x;
                a.py = a.y;
                return a
            },
            redrawAll: function() {
                d.nodes.forEach(function(a, b) {
                    a.data = that.setTheme(a.data);
                    editorPane.setNodeColor(b, a.data.color);
                    a.data.redraw = true
                });
                d.links.forEach(function(a) {
                    a.data.color = e.lineColor;
                    a.data.weight = e.lineWidth;
                    a.data.redraw = true
                });
                editorPane.refresh(); // ask editorPane to reflect any changes if needed
                that.redraw() // regardless of there is any change from editorPane we have to redraw, due to node updates.
            },
            moveViewToCurrentSelection: function() {
                if(shiftKey) return;
                let [nb, ne] = editorPane.findSelectedNodes()
                if(nb != ne || nb < -1) {
                    return;
                }
                let n = d.nodes[nb]
                if(!n) return;
                let scl = that.settings("scale")
                let w = $("#stageHolder").width()
                let h = $("#stageHolder").height()
                let newx = -n.x * scl + w / 2
                let newy = -n.y * scl + h / 2
                let curx = l.getX()
                let cury = l.getY()
                if(newx < curx-w/2.2 || newx > curx+w/2.2 || newy < cury-h/2.2 || newy > cury+h/2.2) {
                    l.setPosition(newx, newy)
                }
            },
            redraw: function() {
                d.links.forEach(function(a) {
                    a.ui && !a.data.redraw ? a.ui.setPoints([a.source, a.target]) : (a.ui && (a.ui.hasOwnProperty("removeChildren") && a.ui.removeChildren(), a.ui.remove()), a.ui = that.newLine(a, a.source, a.target), l.add(a.ui), a.ui.moveToBottom(), a.data.redraw = !1)
                });
                let [nb, ne] = editorPane.findSelectedNodes()
                function checkRedraw(pos) {
                    let inrange = (pos >= nb && pos <= ne);
                    let p_inrange = (pos >= that.prevNb && pos <= that.prevNe);
                    return (inrange && !p_inrange) || (!inrange && p_inrange);
                }
                d.nodes.forEach(function(a, pos) {
                    if(a.ui && !checkRedraw(pos) && !a.data.redraw) {
                        a.ui.setPosition(a.x, a.y)
                    } else {
                        if(a.ui) {
                            a.ui.removeChildren()
                            a.ui.remove()
                        }
                        let selected = (pos >= nb && pos <= ne)
                        let g = that.newGroup(a, selected)
                        a.ui = g[0]
                        a.w = g[1]
                        a.h = g[2]
                        l.add(a.ui)
                        a.data.redraw = false
                    }
                });
                that.prevNb = nb;
                that.prevNe = ne;
                l.draw()
            },
            newLine: function(a, b, c) {
                if (a.data.label) {
                    var d = c.x - b.x;
                    c = c.y - b.y;
                    var e = new Kinetic.Line({
                            points: [{
                                x: 0,
                                y: 0
                            }, {
                                x: d,
                                y: c
                            }],
                            stroke: a.data.color,
                            strokeWidth: a.data.weight
                        }),
                        f = new Kinetic.Text({
                            text: a.data.label,
                            fontSize: 11,
                            fontFamily: "Arial",
                            fill: "#666",
                            x: 0.5 * d - 50,
                            y: 0.5 * c - 6,
                            width: 100,
                            align: "center"
                        }),
                        u = new Kinetic.Group({
                            x: b.x,
                            y: b.y
                        });
                    u.add(e);
                    u.add(f);
                    u.setPoints = function(a) {
                        var b = a[1].x - a[0].x,
                            c = a[1].y - a[0].y;
                        e.setPoints([{
                            x: 0,
                            y: 0
                        }, {
                            x: b,
                            y: c
                        }]);
                        f.setPosition(0.5 * b - 50, 0.5 * c - 6);
                        u.setPosition(a[0].x, a[0].y)
                    };
                    return u
                }
                return new Kinetic.Line({
                    points: [b, c],
                    stroke: a.data.color,
                    strokeWidth: a.data.weight
                })
            },
            newGroup: function(a, selected) {
                var b =
                    new Kinetic.Group({
                        x: a.x,
                        y: a.y
                    }),
                    c = that.newText(a)
                if(a.data.comment != "") { // && that.settings("scale") * a.data.fontSize > 16) {
                    var cc = that.newComment(a)
                    var width = Math.max(c.getWidth(), cc.getWidth()) + 4;
                    var height = c.getHeight() + cc.getHeight()
                    var rec = that.newRect(a, width, height, selected);
                    c.setPosition(-0.5 * width, -0.5 * height);
                    cc.setPosition(-0.5 * width, -0.5 * height + c.getHeight());
                    b.add(rec);
                    b.add(cc);
                } else {
                    var width = c.getWidth() + 4;
                    var height = c.getHeight()
                    var rec = that.newRect(a, width, height, selected);

                    c.setPosition(-0.5 * width, -0.5 * height);
                    b.add(rec);
                }
                b.add(c);
                b.on("touchstart mousedown", function(b) {
                    if(!editorPane.isEditable()) {
                        return;
                    }
                    b.stopPropagation();
                    b.preventDefault();

                    if(b.shiftKey) {
                        // m should be all the children of 'a'
                        m = [a]
                        d.nodes.forEach( (n) => {
                            if(m.indexOf(n.data.parent) >= 0) {
                                m.push(n)
                            }
                        })
                    } else {
                        m = [a]
                    }
                    window.getSelection().removeAllRanges()
                    a.fixed = true;
                    C = n(b.pageX || b.targetTouches[0].pageX, b.pageY || b.targetTouches[0].pageY);
                });
                b.on("mouseover", function() {
                    if(!shiftKey) {
                        B.style.cursor = "pointer";
                        let [nb, ne] = editorPane.findSelectedNodes()
                        let idx = d.nodes.indexOf(a)
                        if( nb != idx || ne != idx) {
                            editorPane.moveCursorToNode(idx);
                            d.nodes[idx].data.redraw = true
                            editorPane.refresh(); // ask editorPane to reflect any changes if needed
                            that.redraw() // regardless of there is any change from editorPane we have to redraw, due to node updates.

                        }
                    }
                });
                b.on("mouseup touchend", function() {
                    let [nb, ne] = editorPane.findSelectedNodes()
                    let idx = d.nodes.indexOf(a)
                    if( nb != idx || ne != idx) {
                        editorPane.moveCursorToNode(idx);
                        that.redraw()
                    }
                });
                b.on("mouseout", function() {
                    if(m.length == 0) {
                        B.style.cursor = "move"
                    }
                    that.redraw()
                });
                return [b, width, height]
            },
            newRect: function(a, b, c, selected) {
                return new Kinetic.Rect({
                    x: -0.5 * b - 1,
                    y: -0.5 * c,
                    width: b + 2,
                    height: c,
                    cornerRadius: 2,
                    fill: a.data.color,
                    opacity: 1,
                    shadowColor: "#999",
                    shadowBlur: 2,
                    shadowOffset: 2,
                    stroke: "#000000",
                    strokeWidth: selected ? 4 : 0.01,
                    shadowOpacity: 0.5
                })
            },
            newComment: function(a) {
                var g = new Kinetic.Text({
                        x: 0,
                        y: 0,
                        text: a.data.comment,
                        lineHeight: 1.1,
                        fontSize: a.data.fontSize * 0.8,
                        fontFamily: a.data.font,
                        fill: a.data.fontColor,
                        opacity:0.8,
                        padding: 10 - Math.min(a.data.level*3, 5),
                        align: "left"
                    }),
                    c = that.maxTextWidth(a);
                let wh = g.getWidth() * g.getHeight();
                g.getWidth() > c && g.setAttrs({
                    width: Math.max(c, Math.sqrt(wh))
                });
                return g
            },

            newText: function(a) {
                var g = new Kinetic.Text({
                        x: 0,
                        y: 0,
                        text: a.data.label,
                        lineHeight: 1.1,
                        fontSize: a.data.fontSize,
                        fontFamily: a.data.font,
                        fill: a.data.fontColor,
                        padding: 10 - Math.min(a.data.level*3, 5),
                        align: "left"
                    }),
                    c = that.maxTextWidth(a);
                let wh = g.getWidth() * g.getHeight();
                g.getWidth() > c && g.setAttrs({
                    width: Math.max(c, Math.sqrt(wh))
                });

                return g
            },
            maxTextWidth: function(a) {
                if(a.data.fontSize in that.maxTextWidthCache) {
                    if(a.data.font in that.maxTextWidthCache[a.data.fontSize]) {
                        return that.maxTextWidthCache[a.data.fontSize][a.data.font] 
                    }
                } else {
                    that.maxTextWidthCache[a.data.fontSize] = {}
                }
                var t = new Kinetic.Text({
                    text: "MMMMMMMMMMMMMMMMMMMM",
                    fontSize: a.data.fontSize,
                    fontFamily: a.data.font
                })
                var ret = t.getWidth()
                t.remove()
                that.maxTextWidthCache[a.data.fontSize][a.data.font] = ret
                return ret
            },
            findParent: function(b, c) {
                if (0 == b) return -1;
                for (let a = c[b]; 0 <= b; b--) {
                    if (c[b] < a) {
                        return b;
                    }
                }
                return -1;
            },
            hashCode: function(a) {
                var b = 0;
                if (0 == a.length) return b;
                for (i = 0; i < a.length; i++) var c = a.charCodeAt(i),
                    b = (b << 5) - b + c;
                return b
            },
            exportPositions: function() {
                var a = [];
                d.nodes.forEach(function(b, c) {
                    var e = parseFloat(b.x).toFixed(2),
                        d = parseFloat(b.y).toFixed(2);
                    a.push({
                        i: c,
                        x: e,
                        y: d,
                        f: b.fixed
                    })
                });
                return a
            },
            text2mindmap: function(a) {
                function convert_to_comment(x) {
                    x = x.trim()
                    if(x.substring(0, 2) == "\0+") {
                        return x.substring(2)
                    } else return ""
                }
                    
                var b = a.split(/\n/)
                var c = [], j = 0
                var comments = []
                for(var i=0; i<b.length; i++) {
                    if(b[i].match(/^\s*\0-/)) {
                        c[j] = b[i]
                        comments[j] = ""
                        j++
                    } else if(j > 0) {
                        comments[j-1] += "\n" + convert_to_comment(b[i])
                    }
                }
                b = c.join("\n");
                a = difflib.stringAsLines(b);
                if(comments.length == 0) {
                    comments[0]= ""
                }
                var w = [],
                    z = [];
                A = 0;
                a.forEach(function(a, c) {
                    w[c] = indent_depth(a);
                    z[c] = that.findParent(c, w);
                });
                w[0] = 0;
                for(var i=0; i<w.length; i++) {
                    if (z[i] < 0) {
                        w[i] = 0;
                    } else {
                        w[i] = w[z[i]] + 1;
                    }
                    (D < w[i]) && (D = w[i]);
                }

                try {
                    var c = difflib.stringAsLines(y)
                    var e = (new difflib.SequenceMatcher(c, a)).get_opcodes()
                    var addedNodes = 0, removedNodes = 0, modifiedNodes = 0
                    for (var l = 0; l < e.length; l++) {
                        var entry = e[l]
                        var n = entry[0], q = entry[1], r = entry[2], p = entry[3], k = entry[4]
                        var x = Math.max(r - q, k - p)
                        for ( var v = 0; v < x; v++) {
                            if ("delete" == n || "replace" == n && p == k) {
                                var s = q - removedNodes + addedNodes;
                                that.removeNode(s);
                                removedNodes++
                            } else if ("insert" == n ||
                                "replace" == n && q == r || "replace" == n && !c[q]) {
                                var s = q - removedNodes + addedNodes;
                                var t = trim_label(a[p]);
                                that.addNode(s, {
                                    label: t.label,
                                    comment: comments[p].trim(),
                                    linkLabel: t.linkLabel,
                                    children: 0,
                                    all_children: 0,
                                    fixed: p==0 || t.fixed,
                                    x: t.x,
                                    y: t.y,
                                });
                                addedNodes++
                            } else if("replace" == n) {
                                // XXX : usually we only need to update nodes that the text is updated.
                                var s = q - removedNodes + addedNodes;
                                var t = trim_label(a[p])
                                if(t == null) {
                                    that.removeNode(s);
                                    removedNodes++
                                } else {
                                    d.nodes[s].data.label = t.label
                                    d.nodes[s].fixed = (p==0 || t.fixed)
                                    if (t.fixed) {
                                        d.nodes[s].x = t.x
                                        d.nodes[s].y = t.y
                                        d.nodes[s].px = t.x
                                        d.nodes[s].py = t.y
                                    }
                                    d.nodes[s].data.comment = comments[p].trim()
                                    d.nodes[s].data.linkLabel = t.linkLabel
                                }
                                modifiedNodes++;
                            } else if("equal" == n) {
                                var s = q - removedNodes + addedNodes;
                                if(s < d.nodes.length) {
                                    if(d.nodes[s].data.comment != comments[p].trim()) modifiedNodes++;
                                    d.nodes[s].data.comment = comments[p].trim()
                                }
                            }
                            q = q < r ? q + 1 : q;
                            p = p < k ? p + 1 : p
                        }
                    }
                } catch (x) {
                    // XXX : we may have some unhandled cases.  Fallback by clearing everything and starting over.
                    console.log(x)
                    that.clear()
                    return false
                }
                y = b;

                d.nodes.forEach(function(a, b) {
                    if(w[b] == 0) {
                        A = 0;
                    }
                    a.data.branch = 1 == w[b] ? ++A : A;
                    // if we changed levels then we reset location
                    if(a.data.level != w[b] && !a.fixed) {
                        a.x = undefined;
                        a.y = undefined;
                    }
                    a.data.level = w[b];
                    a.data.parent = z[b] < 0 ? false : d.nodes[z[b]];
                    a.data = that.setTheme(a.data);
                    a.data.redraw = true;
                    if(a.data.parent && !that.isLinkedTo(a, a.data.parent)) {
                        a.data.parent.data.children++
                        that.getLinksFrom(a).forEach(function(a) {
                            that.removeLink(a)
                        })
                        that.addLink(a, a.data.parent);
                    } else if(!a.data.parent) {
                        that.getLinksFrom(a).forEach(function(a) {
                            that.removeLink(a)
                        })
                    }
                    var c = that.getLinksFrom(a)[0]; // parent-side connection
                    if(c && c.data.label != a.data.linkLabel) {
                        c.data.label = a.data.linkLabel
                        c.data.redraw = true
                    }
                    editorPane.setNodeColor(b, a.data.color);
                });
                let updatedRate = (modifiedNodes + addedNodes + removedNodes - 5) / (d.nodes.length + 1e-6);
                that.buildStartingPos(updatedRate);
                return true
            },
            repositionFloatingNodes: function() {
                let total = 0, count = 0;

                d.nodes.forEach(function(a) {
                    if(!a.fixed && a.data.parent) {
                        a.x = undefined;
                        a.y = undefined;
                        a.px = undefined;
                        a.py = undefined;
                        count++;
                    }
                    total++;
                });
                that.buildStartingPos(count/total);
            },
            buildStartingPos : function(updatedRate) {
                d.nodes.forEach(function(a, b) {
                    a.fixedtemp = a.fixed;
                    if("undefined" == typeof a.x) {
                        that.setStartPosition(a, b, d.nodes.length);
                    } else {
                        a.fixed = true;
                    }
                });
                for(let size_scale = Math.max(0.0625, 1 - updatedRate); size_scale <= 1.0; size_scale *= 2) {
                    let n = d.links;

                    let no_swap = false;
                    for(let iter = 0; iter < 10 && !no_swap; iter++) {
                        no_swap = true;
                        for(let i=0; i<n.length; ++i) {
                            for(let j=i+1; j<n.length; ++j) {
                                if(n[i].source == n[j].source || 
                                    n[i].source == n[j].target || 
                                    n[i].target == n[j].source || 
                                    n[i].target == n[j].target)
                                {
                                    continue;
                                }
                                function links_intersect(link1, link2) {
                                    if(link1.source == link2.source || link1.target == link2.target || link1.source == link2.target || link1.target == link2.source) return false;
                                    function intersect_eq(x, y, link) {
                                        let x1 = link.source.x;
                                        let y1 = link.source.y;
                                        let x2 = link.target.x;
                                        let y2 = link.target.y;
                                        return (y2 - y1) * x - (x2 - x1) * y + x2 * y1 - x1 * y2;
                                    }
                                    let v1 = intersect_eq(link1.source.x, link1.source.y, link2) * intersect_eq(link1.target.x, link1.target.y, link2) < 0;
                                    let v2 = intersect_eq(link2.source.x, link2.source.y, link1) * intersect_eq(link2.target.x, link2.target.y, link1) < 0;
                                    return v1 && v2;
                                }
                                if(n[i].source.fixed && n[j].source.fixed) {
                                    continue;
                                }
                                if(links_intersect(n[i], n[j])) {
                                    if(!n[i].source.fixed && !n[j].source.fixed) {
                                        let tmp;
                                        tmp = n[i].source.x; n[i].source.x = n[j].source.x; n[j].source.x = tmp;
                                        tmp = n[i].source.y; n[i].source.y = n[j].source.y; n[j].source.y = tmp;
                                        no_swap = false;
                                    } else if(!n[i].source.fixed) {
                                        n[i].source.x = n[i].target.x;
                                        n[i].source.y = n[i].target.y;
                                        no_swap = false;
                                    }
                                    else if(!n[j].source.fixed) {
                                        n[j].source.x = n[j].target.x;
                                        n[j].source.y = n[j].target.y;
                                        no_swap = false;
                                    }
                                }
                            }
                        }
                    }
                    that.createSimulation(Math.min(1.0, size_scale))
                        .alpha(0.3)
                        .alphaDecay(0)
                        .tick(300).stop();
                }

                d.nodes.forEach(function(a) {
                    a.fixed = a.fixedtemp;
                });
            },
            setTheme: function(a) {
                a.font = e.font;
                a.fontColor = e.fontColor ? e.fontColor : "#fff";
                a.fontSize = Math.max(e.fontMinSize, Math.round(e.fontSize *
                    (1 - 0.17 * a.level)));
                if(e.coloringMode == 1) {
                    a.color = a.level >= e.bgcolors.length ? e.bgcolors[e.bgcolors.length - 1] : e.bgcolors[a.level];
                } else {
                    if(!a.parent) {
                        a.color = e.bgcolors[0];
                    } else {
                        a.color = a.branch >= e.bgcolors.length ? e.bgcolors[e.bgcolors.length - 1] : e.bgcolors[a.branch];
                    }
                }
                if ("undefined" == typeof a.color || null == a.color) a.color = "#eeeeee";
                var b;
                var c = a.color;
                if (c) {
                    c = c.replace(/^\s*#|\s*$/g, "");
                    3 == c.length && (c = c.replace(/(.)/g, "$1$1"));
                    b = parseInt(c.substr(0, 2), 16);
                    var d = parseInt(c.substr(2, 2), 16),
                        c = parseInt(c.substr(4, 2), 16);
                    b = "#" + (0 | 256 + b + 10 * (256 - b) / 100).toString(16).substr(1) +
                        (0 | 256 + d + 10 * (256 - d) / 100).toString(16).substr(1) + (0 | 256 + c + 10 * (256 - c) / 100).toString(16).substr(1)
                } else b = void 0;
                a.shadow = b;
                return a
            },
            text2tree: function(a) {
                y = text = a.split(/\n/).filter(function(a) {
                    return a.match(/\S/)
                });
                var d, c = [],
                    e = [];
                b.each(text, function(a, b) {
                    e[a] = G(b);
                    var f = that.findParent(text, a, e),
                        k = {
                            name: b,
                            children: [],
                            lineNbr: a
                        };
                    0 == a ? (d = k, c[a] = k) : (c[a] = k, c[f].children.push(k))
                });
                // console.log(JSON.stringify(d));
                return d
            }
        }
    };

    Array.prototype.forEach || (Array.prototype.forEach = function(b, r) {
        var n, e;
        if (null ==
            this) throw new TypeError(" this is null or not defined");
        var p = Object(this),
            w = p.length >>> 0;
        if ("[object Function]" != {}.toString.call(b)) throw new TypeError(b + " is not a function");
        r && (n = r);
        for (e = 0; e < w;) {
            var y;
            e in p && (y = p[e], b.call(n, y, e, p));
            e++
        }
    })
    return {
        render, redraw,
        updateCanvasSize,
        moveViewToCurrentSelection
        
    }
})();
